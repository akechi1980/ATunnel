package com.szming.utils;

import java.io.UnsupportedEncodingException;
import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TunnelUtils {

	public static String bytes2HexString(byte[] b) {
		String ret = "";
		for (int i = 0; i < b.length; i++) {
			String hex = Integer.toHexString(b[i] & 0xFF);
			if (hex.length() == 1) {
				hex = '0' + hex;
			}
			ret += hex.toUpperCase();
		}
		return ret;
	}


	
	public static byte[] CreateHash(String message) {
		byte[] key = null;
		try {
			key = (message).getBytes("UTF-8");
			MessageDigest sha = MessageDigest.getInstance("SHA-256");
			key = sha.digest(key);
//			System.out.println(Utils.bytes2HexString(key));
			key = Arrays.copyOf(key, 16); // use only first 128 bit
//			System.out.println(Utils.bytes2HexString(key));
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NoSuchAlgorithmException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return key;
	}
	
	
    //............encode............
    public static byte[] encode(byte[] inbuf,String method,String pass) {
    	byte[] result = null;
        try{

        }catch(Exception e){
        	e.printStackTrace();
        }
    
        return result;
    }
    
    //............encode............
    public static byte[] decode(byte[] inbuf,String method,String pass) {
    	byte[] result = null;
        try{

        }catch(Exception e){
        	e.printStackTrace();
        }
    
        return result;
    }
    
    
    /**
     * AES加密字符串
     * 
     * @param content
     *            需要被加密的字符串
     * @param password
     *            加密需要的密码
     * @return 密文
     */
    public static byte[] encrypt(String content, String password) {
        try {

//            KeyGenerator kgen = KeyGenerator.getInstance("AES");// 创建AES的Key生产者
//
//            //kgen.init(192);
//            //kgen.init(192, new SecureRandom(password.getBytes()));// 利用用户密码作为随机数初始化出128位的key生产者
//            
//            //加密没关系，SecureRandom是生成安全随机数序列，password.getBytes()是种子，只要种子相同，序列就一样，所以解密只要有password就行
//
//            SecretKey secretKey = kgen.generateKey();// 根据用户密码，生成一个密钥
//
//            byte[] enCodeFormat = secretKey.getEncoded();// 返回基本编码格式的密钥，如果此密钥不支持编码，则返回
//                                                            // null。
//
//            SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES");// 转换为AES专用密钥
//
//            Cipher cipher = Cipher.getInstance("AES");// 创建密码器
//
//            byte[] byteContent = content.getBytes("utf-8");
//
//            cipher.init(Cipher.ENCRYPT_MODE, key);// 初始化为加密模式的密码器
//
//            byte[] result = cipher.doFinal(byteContent);// 加密
        	
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(
                    Cipher.ENCRYPT_MODE,
                    new SecretKeySpec(password.getBytes(), "AES"),
                    new IvParameterSpec(new byte[16])//初始化16空字节
            );
            byte[] encrypted = cipher.doFinal(content.getBytes());
            return encrypted;

        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    
//	
//    /**
//     * Encrypts data.
//     * @param plainText
//     *   Data to encrypt.
//     * @return
//     *   Encrypted data.
//     * @throws Exception
//     *   If something went wrong.
//     */
//    public static byte[] encrypt(String plainText){
//    	Cipher cipher;
//    	cipher = Cipher.getInstance("PBEWithMD5AndDES");
//    	String secretKey = "123456789";
//    	
//        byte[] encrypted = new byte[plainText.getBytes().length];
//        
//        cipher.init(Cipher.ENCRYPT_MODE, secretKey, this.paramSpec);
//        encrypted = cipher.doFinal(plainText.getBytes());
//        return encrypted;
//    }
//    
//    
//    /**
//     * Decrypts data.
//     * @param cipherText
//     *   Data to decrypt.
//     * @return
//     *   Decrypted data.
//     * @throws Exception
//     *   If something went wrong.
//     */
//    public static String decrypt(byte[] cipherText) throws Exception {
//    	
//    	Cipher cipher;
//    	cipher = Cipher.getInstance("PBEWithMD5AndDES");
//    	String secretKey = "123456789";
//    	
//        byte[] decryptedText = new byte[cipherText.length];
//        String decrypted;
//        
//        cipher.init(Cipher.DECRYPT_MODE, secretKey, this.paramSpec);
//        decryptedText = cipher.doFinal(cipherText);
//        decrypted = new String(decryptedText);
//        return decrypted;
//    }
//    
}
